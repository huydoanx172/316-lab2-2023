import sys
import json

from urllib.request import Request, urlopen
from urllib.parse import urlencode
from urllib.error import HTTPError

from crypto import Credential, Certificate, AccessRequest, new_user
from auth import generate_request
from logic import *
from util import *
from proofrules import *
from parser import parse, fmla_parse
from verifier import verify
from prover import *
from auth import *


def generate_exploit():
	fakeCA_cert = new_user(Agent("#caa"), Agent("#caa"))
	fakeCA_key = fingerprint(fakeCA_cert.public_key)

	creds = []
	certs = []

	# Malware public key assigned to #root
	key = Certificate.load_certificate(Agent("#pdoan"))
	# print("key =", fingerprint(key.public_key))
	cert = Certificate.make_for_key(key.public_key, Agent("#root"), Agent("#caa"))
	certs.append(cert)

	# Fake ca's public key cert
	key = Certificate.load_certificate(Agent("#caa"))
	cert = Certificate.make_for_key(key.public_key, Agent("#caa"), Agent("#caa"))
	certs.append(cert)

	# My cert
	myCert = Certificate.load_certificate(Agent("#pdoan"))
	myKey = myCert.public_key
	certs.append(Certificate.make_for_key(myKey, Agent("#pdoan"), Agent("#caa")))

	# Credential by #root's malware key saying that #pdoan can open <bigsecret.txt>
	P = parse("open(#pdoan, <bigsecret.txt>)")
	cred = Credential.from_formula(P, Agent("#pdoan"))
	creds.append(cred)

	# Get the proof
	# The sequent to be proven when constructing the malicious AccessRequest
	seq = parse(f"""ca(#caa), iskey(#caa, {fakeCA_key}),
    sign((iskey(#root, [f5:52:6c:d3:bb:50:f3:ad:2d:90:7c:21:cc:52:53:f8])), {fakeCA_key}),
    sign((open(#pdoan, <bigsecret.txt>)), [f5:52:6c:d3:bb:50:f3:ad:2d:90:7c:21:cc:52:53:f8])
	|- (#root says open(#pdoan, <bigsecret.txt>))""")

	t = ThenTactic(
		[
			# Convince that the malware key belongs to #root
			SignTactic(parse(f'sign(iskey(#root, [f5:52:6c:d3:bb:50:f3:ad:2d:90:7c:21:cc:52:53:f8]), {fakeCA_key})'), Agent('#caa')),
			CertTactic(Agent('#root'), Key('[f5:52:6c:d3:bb:50:f3:ad:2d:90:7c:21:cc:52:53:f8]'), Agent('#caa'), Key(f'{fakeCA_key}')),

			# Get #root says open() in gamma
			SignTactic(parse(f'sign((open(#pdoan, <bigsecret.txt>)), [f5:52:6c:d3:bb:50:f3:ad:2d:90:7c:21:cc:52:53:f8])'), Agent('#root')),
			# Close the proof
			RuleTactic(identityRule)
		]
	)
	pf = get_one_proof(seq, t)
	# print(stringify(pf))

	ag = Agent("#pdoan")

	return AccessRequest.make_for_proof(pf, ag, creds, certs)

if __name__ == '__main__':

	req = generate_exploit()
	# verify_request(req)
	if req is None:
		sys.exit(0)

	request = Request("http://authproof.net:15316/accessrequest",
					  data=urlencode({
						  "request": req.serialize()
					  }).encode('utf-8'),
					  headers={'Content-Encoding': 'gzip'},
					  method='POST')
	try:
		response_object = urlopen(request, timeout=10)
	except HTTPError as e:
		response_object = e

	print("response object =", response_object)
	resp_json = json.load(response_object)
	print('\nserver response:')
	try:
		new_cred = Credential.from_json(resp_json)
		print(new_cred)
	except:
		print(resp_json)